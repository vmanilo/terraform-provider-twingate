package resource

import (
	"context"
	"errors"

	"github.com/Twingate/terraform-provider-twingate/twingate/internal/attr"
	"github.com/Twingate/terraform-provider-twingate/twingate/internal/client"
	"github.com/Twingate/terraform-provider-twingate/twingate/internal/model"
	"github.com/Twingate/terraform-provider-twingate/twingate/internal/utils"
	tfattr "github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the desired interfaces.
var _ resource.Resource = &serialNumbers{}

func NewSerialNumbersResource() resource.Resource {
	return &serialNumbers{}
}

type serialNumbers struct {
	client *client.Client
}

type serialNumbersModel struct {
	ID              types.String `tfsdk:"id"`
	SerialNumbers   types.Set    `tfsdk:"serial_numbers"`
	IsAuthoritative types.Bool   `tfsdk:"is_authoritative"`
}

func (r *serialNumbers) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = TwingateSerialNumbers
}

func (r *serialNumbers) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*client.Client)
}

func (r *serialNumbers) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// TODO: add description
		Description: "This resource should be a singleton. There should only be a single instance of twingate_serial_numbers.",
		Attributes: map[string]schema.Attribute{
			attr.SerialNumbers: schema.SetAttribute{
				Required:    true,
				ElementType: types.StringType,
				Description: "The set of verified serial numbers for the Twingate account.",
			},
			// optional
			attr.IsAuthoritative: schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(true),
				Description: "Determines whether this list will overwrite any existing list. Default is `true`. If set of `false`, assignments made outside of Terraform will be ignored.",
			},
			// computed
			attr.ID: schema.StringAttribute{
				Computed:    true,
				Description: "Autogenerated ID of the Serial Numbers resource.",
			},
		},
	}
}

func (r *serialNumbers) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan serialNumbersModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	numbers, err := r.client.CreateSerialNumbers(ctx,
		utils.Map(plan.SerialNumbers.Elements(), func(item tfattr.Value) string {
			return item.(types.String).ValueString()
		}),
	)

	r.helper(ctx, user, &plan, &resp.State, &resp.Diagnostics, err, operationCreate)
}

func (r *serialNumbers) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state serialNumbersModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	numbers, err := r.client.ReadSerialNumbers(ctx)

	r.helper(ctx, user, &state, &resp.State, &resp.Diagnostics, err, operationRead)
}

func (r *serialNumbers) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state serialNumbersModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	user, err := r.client.CreateSerialNumbers(ctx, userUpdateReq)

	r.helper(ctx, user, &state, &resp.State, &resp.Diagnostics, err, operationUpdate)
}

func (r *serialNumbers) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state serialNumbersModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	addErr(&resp.Diagnostics, isAllowedToChangeUser(&state), operationDelete, TwingateUser)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteUser(ctx, state.ID.ValueString())
	addErr(&resp.Diagnostics, err, operationDelete, TwingateUser)
}

func (r *serialNumbers) helper(ctx context.Context, user *model.User, state *userModel, respState *tfsdk.State, diagnostics *diag.Diagnostics, err error, operation string) {
	if err != nil {
		if errors.Is(err, client.ErrGraphqlResultIsEmpty) {
			// clear state
			respState.RemoveResource(ctx)

			return
		}

		addErr(diagnostics, err, operation, TwingateUser)

		return
	}

	state.ID = types.StringValue(user.ID)
	state.FirstName = types.StringValue(user.FirstName)
	state.LastName = types.StringValue(user.LastName)
	state.Role = types.StringValue(user.Role)
	state.Type = types.StringValue(user.Type)
	state.IsActive = types.BoolValue(user.IsActive)

	// Set refreshed state
	diags := respState.Set(ctx, state)
	diagnostics.Append(diags...)
}
